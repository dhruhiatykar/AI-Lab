import random

N = 4  

def random_state():
    """Generates a random state: one queen per column, placed in a random row"""
    return [random.randint(0, N - 1) for _ in range(N)]

def compute_heuristic(state):
    """Counts number of pairs of queens that are attacking each other"""
    conflicts = 0
    for i in range(N):
        for j in range(i + 1, N):
            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def get_neighbors(state):
    """Generates all neighboring states by moving each queen to a different row in the same column"""
    neighbors = []
    for col in range(N):
        for row in range(N):
            if state[col] != row:
                new_state = state.copy()
                new_state[col] = row
                neighbors.append(new_state)
    return neighbors

def print_board(state):
    """Prints the board in a human-readable format"""
    for row in range(N):
        line = ""
        for col in range(N):
            if state[col] == row:
                line += " Q "
            else:
                line += " . "
        print(line)
    print()

def hill_climbing():
    current = random_state()
    steps = 0
    while True:
        steps += 1
        neighbors = get_neighbors(current)
        current_heuristic = compute_heuristic(current)
        if current_heuristic == 0:
            return current, steps, True  # Solution found

        neighbor = min(neighbors, key=compute_heuristic)
        neighbor_heuristic = compute_heuristic(neighbor)

        if neighbor_heuristic >= current_heuristic:
          
            return current, steps, False

        current = neighbor
solution, steps_taken, is_solution = hill_climbing()

print(" Final State (Column-wise queen positions):", solution)
print("Heuristic Value (0 = perfect solution):", compute_heuristic(solution))
print("Steps taken:", steps_taken)
print(" Board Layout:\n")
print_board(solution)

if is_solution:
    print("Success! Found a valid solution.")
else:
    print("Reached a local optimum. Try again or use random restarts.")
